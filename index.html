<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame WebXRæ¡†æ¶ -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- MindARå›¾åƒè¿½è¸ªåº“ -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  <!-- A-Frameæ‰©å±•ç»„ä»¶ -->
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>
  <style>
    .loading-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 999;
      display: none;
    }
  </style>
</head>

<body>
  <!-- 
    ================================================
    åƒä½›æ´æ—¶å…‰ä¹‹é—¨ - ARå¤åŸé¡¹ç›®
    ================================================
    é¡¹ç›®æè¿°ï¼šåŸºäºA-Frameå’ŒMindARæŠ€æœ¯çš„å¢å¼ºç°å®çŸ³çªŸå¤åŸä½“éªŒ
    ä¸»è¦åŠŸèƒ½ï¼š
    1. å›¾åƒè¯†åˆ« - è¯†åˆ«åƒä½›æ´æ ‡è®°å›¾åƒ
    2. ARæ¸²æŸ“ - åœ¨ç°å®åœºæ™¯ä¸­å åŠ è™šæ‹Ÿå†…å®¹
    3. éŸ³æ•ˆç³»ç»Ÿ - æä¾›æ²‰æµ¸å¼å¬è§‰ä½“éªŒ
    4. äº¤äº’åŠ¨ç”» - å¤åŸåŠ¨ç”»åºåˆ—
    
    æŠ€æœ¯æ ˆï¼š
    - A-Frame: WebXRæ¡†æ¶
    - MindAR: å›¾åƒè¿½è¸ª
    - Three.js: 3Dæ¸²æŸ“
    - WebGL: åº•å±‚å›¾å½¢æ¸²æŸ“
    ================================================
    -->

  <!-- å¯åŠ¨ç•Œé¢ -->
  <div id="startScreen"
    style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); display: flex; justify-content: center; align-items: center; z-index: 1000; font-family: Arial, sans-serif;">
    <div style="text-align: center; color: white;">
      <h1
        style="font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,215,0,0.5); background: linear-gradient(45deg, #ffd700, #ffed4e); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
        âœ¨ åƒä½›æ´æ—¶å…‰ä¹‹é—¨ âœ¨</h1>
      <p style="font-size: 1.3em; margin-bottom: 10px; opacity: 0.9;">ç©¿è¶Šåƒå¹´ï¼Œè§è¯çŸ³çªŸé‡ç”Ÿ</p>
      <p style="font-size: 1em; margin-bottom: 30px; opacity: 0.7;">ä½“éªŒç¥ç§˜çš„ARå¤åŸä¹‹æ—…</p>
      <button id="startButton" style="
          background: linear-gradient(45deg, #ffd700, #ff6b6b); 
          color: white; 
          border: none; 
          padding: 18px 40px; 
          font-size: 1.3em; 
          font-weight: bold;
          border-radius: 30px; 
          cursor: pointer; 
          box-shadow: 0 5px 20px rgba(255,215,0,0.4);
          transition: all 0.3s;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        "
        onmouseover="this.style.transform='scale(1.05) translateY(-2px)'; this.style.boxShadow='0 7px 25px rgba(255,215,0,0.6)'"
        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 5px 20px rgba(255,215,0,0.4)'">
        ğŸ¯ å¼€å¯æ—¶å…‰ä¹‹é—¨
      </button>
      <p style="font-size: 0.9em; margin-top: 20px; opacity: 0.6;">è¯·ç¡®ä¿æ‚¨å·²å…è®¸æ‘„åƒå¤´æƒé™</p>
    </div>
  </div>

  <!-- åŠ è½½æç¤ºæ–‡æœ¬ -->
  <div class="loading-text">æ­£åœ¨åŠ è½½åœºæ™¯...</div>

  <!-- ARåœºæ™¯é…ç½® -->
  <a-scene mindar-image="imageTargetSrc: ./qianfo.mind; autoStart: false" color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights" vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false" loading-screen="enabled: false">

    <!-- èµ„æºé¢„åŠ è½½ -->
    <a-assets>
      <!-- çŸ³çªŸ3Dæ¨¡å‹ -->
      <a-asset-item id="caveModel" src="./buddhist.glb"></a-asset-item>

      <!-- ç¥¥äº‘æ¨¡å‹ï¼ˆå¦‚æœæœ‰ï¼‰ -->
      <a-asset-item id="cloudModel" src="./cloud.glb"></a-asset-item>

      <!-- é¾™æ¨¡å‹ï¼ˆå¦‚æœæœ‰ï¼‰ -->
      <a-asset-item id="dragonModel" src="./dragon.glb"></a-asset-item>



      <!-- seduè§†é¢‘ - å¾ªç¯æ’­æ”¾ -->
      <video id="seduVideo" src="./sedu.mp4" preload="auto" crossorigin="anonymous" playsinline webkit-playsinline
        loop="false"></video>

      <!-- éŸ³æ•ˆèµ„æº -->
      <audio id="chantAudio" src="./chant.mp3" preload="auto"></audio>
      <audio id="magicSound" src="./magic.mp3" preload="auto"></audio>
      <audio id="bellSound" src="./bell.mp3" preload="auto"></audio>
    </a-assets>

    <!-- æ‘„åƒå¤´é…ç½® -->
    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- å›¾åƒç›®æ ‡å®ä½“ - å½“è¯†åˆ«åˆ°åƒä½›æ´æ ‡è®°æ—¶æ˜¾ç¤ºçš„å†…å®¹ -->
    <a-entity mindar-image-target="targetIndex: 0">



      <!-- seduè§†é¢‘æ’­æ”¾ - å¾ªç¯æ’­æ”¾ -->
      <a-video id="seduVideoPlane" src="#seduVideo" width="2" height="2" position="0 0 -0.3" transparent="true"
        color="#ffffff" opacity="1" visible="false" chroma-key="keyColor: #00ff00; threshold: 0.18; smoothing: 0.04">
      </a-video>


      <!-- çŸ³çªŸæ¨¡å‹ -->
      <a-gltf-model id="caveModel3D" src="#caveModel" position="0 0 0" scale="1 1 1"
        animation="property: rotation; to: 0 360 0; loop: true; dur: 10000" visible="false">
      </a-gltf-model>

      <!-- é¾™çš„é£èˆæ•ˆæœï¼ˆå¦‚æœæœ‰GLBï¼‰ -->
      <a-gltf-model id="dragon" src="#dragonModel" position="1 1 0" scale="0.2 0.2 0.2" opacity="0" animation-mixer
        animation__fly="property: position; to: -1 1 0; dur: 5000; dir: alternate; loop: true; easing: easeInOutQuad"
        animation__fadein="property: opacity; from: 0; to: 1; dur: 2000; delay: 3000" visible="false">
      </a-gltf-model>

    </a-entity>

  </a-scene>

  <script>
    // ================================================
    // JavaScriptæ§åˆ¶é€»è¾‘
    // ================================================

    // Three.jsæ‰©å±•åŠŸèƒ½ - ç²’å­ç³»ç»Ÿç»„ä»¶
    AFRAME.registerComponent('particle-system', {
      init: function () {
        const el = this.el;
        const scene = el.sceneEl.object3D;

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        const particleCount = 100;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 2;
          positions[i * 3 + 1] = Math.random() * 2;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

          colors[i * 3] = 1;
          colors[i * 3 + 1] = 0.84;
          colors[i * 3 + 2] = 0;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });

        this.particleSystem = new THREE.Points(particles, material);
        el.object3D.add(this.particleSystem);
      },

      tick: function (time) {
        if (this.particleSystem) {
          this.particleSystem.rotation.y = time * 0.0001;
          const positions = this.particleSystem.geometry.attributes.position.array;

          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] += Math.sin(time * 0.001 + i) * 0.001;
          }

          this.particleSystem.geometry.attributes.position.needsUpdate = true;
        }
      }
    });

    // è‰²åº¦æŠ å›¾ç»„ä»¶ - å®ç°ç»¿å¹•æŠ åƒæ•ˆæœ
    AFRAME.registerComponent('chroma-key', {
      schema: {
        keyColor: {
          default: '#00ff00'
        }, // æŠ å›¾é¢œè‰²ï¼Œé»˜è®¤ç»¿è‰²
        threshold: {
          default: 0.4
        }, // è‰²å½©é˜ˆå€¼
        smoothing: {
          default: 0.1
        } // è¾¹ç¼˜å¹³æ»‘åº¦
      },

      init: function () {
        this.setupChromaKeyMaterial();
      },

      setupChromaKeyMaterial: function () {
        const el = this.el;
        const data = this.data;

        // ç­‰å¾…è§†é¢‘åŠ è½½å®Œæˆ
        el.addEventListener('materialtextureloaded', () => {
          this.applyChromaKey();
        });

        // å¦‚æœå·²ç»æœ‰æè´¨ï¼Œç›´æ¥åº”ç”¨
        setTimeout(() => {
          this.applyChromaKey();
        }, 1000);
      },

      applyChromaKey: function () {
        const el = this.el;
        const data = this.data;
        const mesh = el.getObject3D('mesh');

        if (!mesh) {
          console.log('ç­‰å¾…meshåŠ è½½...');
          setTimeout(() => this.applyChromaKey(), 500);
          return;
        }

        // è·å–è§†é¢‘å…ƒç´  - ä»srcå±æ€§ä¸­æå–
        const srcAttr = el.getAttribute('src');
        let videoElement;

        if (srcAttr && srcAttr.startsWith('#')) {
          // å¦‚æœæ˜¯å¼•ç”¨IDï¼Œè·å–å¯¹åº”çš„è§†é¢‘å…ƒç´ 
          videoElement = document.querySelector(srcAttr);
        } else {
          // å¦‚æœæ˜¯ç›´æ¥çš„srcï¼ŒæŸ¥æ‰¾å¯¹åº”çš„videoå…ƒç´ 
          videoElement = el.components.material.material.map ?
            el.components.material.material.map.image : null;
        }

        if (!videoElement) {
          console.log('æœªæ‰¾åˆ°è§†é¢‘å…ƒç´ ï¼Œé‡è¯•ä¸­...');
          setTimeout(() => this.applyChromaKey(), 500);
          return;
        }

        console.log('ğŸ¬ æ‰¾åˆ°è§†é¢‘å…ƒç´ :', videoElement);

        // åˆ›å»ºè§†é¢‘çº¹ç†
        const videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

        // è½¬æ¢æŠ å›¾é¢œè‰²ä¸ºRGBå€¼
        const keyColor = new THREE.Color(data.keyColor);

        // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨
        const chromaKeyMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: {
              value: videoTexture
            },
            keyColor: {
              value: new THREE.Vector3(keyColor.r, keyColor.g, keyColor.b)
            },
            threshold: {
              value: data.threshold
            },
            smoothing: {
              value: data.smoothing
            }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            uniform vec3 keyColor;
            uniform float threshold;
            uniform float smoothing;
            varying vec2 vUv;
            
            // RGBè½¬HSVå‡½æ•°
            vec3 rgb2hsv(vec3 c) {
              vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
              vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
              vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
              float d = q.x - min(q.w, q.y);
              float e = 1.0e-10;
              return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }
            
            // å¤šé‡ç»¿è‰²æ£€æµ‹å‡½æ•°
            float detectGreenMultiple(vec3 rgb) {
              // æ–¹æ³•1: RGBæ¯”ä¾‹æ£€æµ‹
              float greenDominance = rgb.g / max(max(rgb.r, rgb.b), 0.001);
              float method1 = step(1.2, greenDominance) * step(0.3, rgb.g);
              
              // æ–¹æ³•2: HSVè‰²ç›¸æ£€æµ‹
              vec3 hsv = rgb2hsv(rgb);
              float hueRange = step(0.2, hsv.x) * step(hsv.x, 0.45); // ç»¿è‰²è‰²ç›¸èŒƒå›´
              float satRange = step(0.2, hsv.y); // é¥±å’Œåº¦é˜ˆå€¼
              float method2 = hueRange * satRange;
              
              // æ–¹æ³•3: ç»¿è‰²å‡å»å…¶ä»–é¢œè‰²
              float greenExcess = rgb.g - max(rgb.r, rgb.b);
              float method3 = step(0.05, greenExcess);
              
              // æ–¹æ³•4: é¢œè‰²è·ç¦»æ£€æµ‹
              vec3 keyHSV = rgb2hsv(keyColor);
              float hueDiff = abs(hsv.x - keyHSV.x);
              if (hueDiff > 0.5) hueDiff = 1.0 - hueDiff;
              float colorDistance = sqrt(hueDiff * hueDiff * 8.0 + pow(abs(hsv.y - keyHSV.y), 2.0) * 4.0);
              float method4 = step(colorDistance, threshold * 1.5);
              
              // ç»¼åˆåˆ¤æ–­ - ä»»ä½•ä¸€ç§æ–¹æ³•æ£€æµ‹ä¸ºç»¿è‰²éƒ½æ ‡è®°
              return max(max(method1, method2), max(method3, method4));
            }
            
            // å¼ºåŠ›è¾¹ç¼˜ä¾µèš€å‡½æ•°
            float aggressiveErosion(vec2 uv) {
              float greenPixels = 0.0;
              float totalPixels = 0.0;
              
              // å‡å°é‡‡æ ·èŒƒå›´ï¼Œä½¿ç”¨2x2ç½‘æ ¼
              for (float x = -2.0; x <= 2.0; x += 1.0) {
                for (float y = -2.0; y <= 2.0; y += 1.0) {
                  vec2 offset = vec2(x, y) * 0.0015; // ç¨å¾®å¢åŠ é‡‡æ ·é—´è·
                  vec4 sampleColor = texture2D(map, uv + offset);
                  
                  if (detectGreenMultiple(sampleColor.rgb) > 0.5) {
                    greenPixels += 1.0;
                  }
                  totalPixels += 1.0;
                }
              }
              
              float greenRatio = greenPixels / totalPixels;
              
              // æé«˜ç»¿è‰²åƒç´ é˜ˆå€¼ï¼Œå‡å°‘è¿‡åº¦ä¾µèš€
              if (greenRatio > 0.4) {
                return 0.0;
              }
              
              // æ›´æ¸©å’Œçš„éƒ¨åˆ†é€æ˜å¤„ç†
              if (greenRatio > 0.25) {
                return 0.6;
              }
              
              return 1.0;
            }
            
            void main() {
              vec4 texColor = texture2D(map, vUv);
              
              // ç¬¬ä¸€æ­¥ï¼šå¤šé‡ç»¿è‰²æ£€æµ‹
              float isGreen = detectGreenMultiple(texColor.rgb);
              
              if (isGreen > 0.5) {
                // å¦‚æœæ£€æµ‹ä¸ºç»¿è‰²ï¼Œç›´æ¥è®¾ä¸ºé€æ˜
                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                return;
              }
              
              // ç¬¬äºŒæ­¥ï¼šHSVè‰²å½©ç©ºé—´ç²¾ç¡®è®¡ç®—
              vec3 texHSV = rgb2hsv(texColor.rgb);
              vec3 keyHSV = rgb2hsv(keyColor);
              
              float hueDiff = abs(texHSV.x - keyHSV.x);
              if (hueDiff > 0.5) hueDiff = 1.0 - hueDiff;
              
              float satDiff = abs(texHSV.y - keyHSV.y);
              float valDiff = abs(texHSV.z - keyHSV.z);
              
              float colorDistance = sqrt(
                hueDiff * hueDiff * 10.0 +  // è¿›ä¸€æ­¥å¢åŠ è‰²ç›¸æƒé‡
                satDiff * satDiff * 5.0 +   // å¢åŠ é¥±å’Œåº¦æƒé‡
                valDiff * valDiff * 2.0     // å¢åŠ æ˜åº¦æƒé‡
              );
              
              // ç¬¬ä¸‰æ­¥ï¼šåŸºç¡€é€æ˜åº¦è®¡ç®—
              float alpha = smoothstep(threshold - smoothing, threshold + smoothing, colorDistance);
              
              // ç¬¬å››æ­¥ï¼šè¾¹ç¼˜ä¾µèš€å¤„ç†
              float erosionAlpha = aggressiveErosion(vUv);
              alpha = min(alpha, erosionAlpha);
              
              // ç¬¬äº”æ­¥ï¼šé¢å¤–çš„ç»¿è‰²æ¸…ç†
              float greenStrength = texColor.g - max(texColor.r, texColor.b);
              if (greenStrength > 0.05) {
                alpha *= 0.6; // å‡å°‘å¤„ç†å¼ºåº¦
              }
              
              // ç¬¬å…­æ­¥ï¼šé¢œè‰²æ¯”ä¾‹æ£€æµ‹
              float greenRatio = texColor.g / max(texColor.r + texColor.b + texColor.g, 0.001);
              if (greenRatio > 0.5) {
                alpha *= 0.4; // æé«˜é˜ˆå€¼ï¼Œå‡å°‘è¯¯ä¼¤
              }
              
              // ç¬¬ä¸ƒæ­¥ï¼šæ›´æ¸©å’Œçš„è¾¹ç¼˜å¤„ç†
              if (alpha < 0.2) {
                alpha = 0.0; // é™ä½é€æ˜é˜ˆå€¼
              } else if (alpha < 0.6) {
                // å‡å°‘é¢œè‰²æ ¡æ­£å¼ºåº¦
                vec3 corrected = texColor.rgb * vec3(1.2, 0.8, 1.1); // æ›´æ¸©å’Œçš„ç»¿è‰²å‡å°‘
                texColor.rgb = mix(texColor.rgb, corrected, 0.4); // å‡å°‘æ··åˆå¼ºåº¦
                alpha = smoothstep(0.2, 0.6, alpha) * 0.95; // ä¿ç•™æ›´å¤šè¾¹ç¼˜ç»†èŠ‚
              }
              
              gl_FragColor = vec4(texColor.rgb, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          alphaTest: 0.01
        });

        mesh.material = chromaKeyMaterial;

        console.log('âœ… è‰²åº¦æŠ å›¾æ•ˆæœå·²åº”ç”¨');
        console.log('ğŸ¨ æŠ å›¾é¢œè‰²:', data.keyColor);
        console.log('ğŸ¯ é˜ˆå€¼:', data.threshold);
        console.log('âœ¨ å¹³æ»‘åº¦:', data.smoothing);
        console.log('ğŸ’¡ è°ƒè¯•æç¤º: ä½¿ç”¨ adjustChromaKey(threshold, smoothing) å‡½æ•°è°ƒæ•´å‚æ•°');

        // æ·»åŠ å…¨å±€è°ƒè¯•å‡½æ•°
        window.adjustChromaKey = function (newThreshold, newSmoothing) {
          if (chromaKeyMaterial && chromaKeyMaterial.uniforms) {
            chromaKeyMaterial.uniforms.threshold.value = newThreshold || data.threshold;
            chromaKeyMaterial.uniforms.smoothing.value = newSmoothing || data.smoothing;
            console.log('ğŸ”§ å‚æ•°å·²æ›´æ–° - é˜ˆå€¼:', chromaKeyMaterial.uniforms.threshold.value, 'å¹³æ»‘åº¦:', chromaKeyMaterial
              .uniforms.smoothing.value);
            console.log('ğŸ’¡ å»ºè®®å‚æ•°èŒƒå›´: threshold(0.05-0.3), smoothing(0.005-0.1)');
            console.log('ğŸ¯ æä¸¥æ ¼æ¨¡å¼: adjustChromaKey(0.1, 0.01)');
            console.log('ğŸ”¥ è¶…ä¸¥æ ¼æ¨¡å¼: adjustChromaKey(0.05, 0.005)');
            console.log('ğŸŒŸ å¹³è¡¡æ¨¡å¼(å½“å‰): adjustChromaKey(0.18, 0.04)');
            console.log('ğŸ’« æ¸©å’Œæ¨¡å¼: adjustChromaKey(0.25, 0.06)');
            console.log('ğŸ“ å¦‚æœè¾¹ç¼˜è¿‡ç¡¬å¯ç¨å¾®å¢åŠ  smoothing å€¼');
            console.log('ğŸ“ å¦‚æœç»¿è‰²æ®‹ç•™å¯ç¨å¾®å‡å°‘ threshold å€¼');
          }
        };
      }
    });

    // æè´¨æ¸å˜ç»„ä»¶ - å®ç°é¢œè‰²è¿‡æ¸¡æ•ˆæœ
    AFRAME.registerComponent('material-transition', {
      schema: {
        duration: {
          default: 3000
        },
        from: {
          default: '#888888'
        },
        to: {
          default: '#ffd700'
        }
      },

      init: function () {
        this.startTime = Date.now();
        this.material = this.el.getObject3D('mesh').material;
      },

      tick: function () {
        const elapsed = Date.now() - this.startTime;
        const progress = Math.min(elapsed / this.data.duration, 1);

        if (this.material && progress < 1) {
          // æ¸å˜æ•ˆæœimplementa
          this.material.emissive = new THREE.Color().lerpColors(
            new THREE.Color(this.data.from),
            new THREE.Color(this.data.to),
            progress
          );
          this.material.emissiveIntensity = progress * 0.5;
        }
      }
    });

    // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
      // UIå…ƒç´ è·å–
      const startScreen = document.getElementById('startScreen');
      const startButton = document.getElementById('startButton');
      const scene = document.querySelector('a-scene');
      const loadingText = document.querySelector('.loading-text');

      // éŸ³é¢‘è®¾ç½®
      const chantAudio = document.querySelector('#chantAudio');
      const magicSound = document.querySelector('#magicSound');
      const bellSound = document.querySelector('#bellSound');

      // éŸ³é¢‘é…ç½®
      if (chantAudio) chantAudio.loop = true;
      if (chantAudio) chantAudio.volume = 0.6;
      if (magicSound) magicSound.volume = 0.8;
      if (bellSound) bellSound.volume = 0.7;

      // åˆå§‹éšè—åœºæ™¯
      scene.style.display = 'none';

      // å¯åŠ¨æŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
      startButton.addEventListener('click', async function () {
        try {
          startScreen.style.display = 'none';
          loadingText.style.display = 'block';
          scene.style.display = 'block';

          // æ‰‹åŠ¨å¯åŠ¨MindARæ‘„åƒå¤´
          const sceneEl = document.querySelector('a-scene');
          if (sceneEl.systems['mindar-image-system']) {
            await sceneEl.systems['mindar-image-system'].start();
          }

          // ç­‰å¾…åœºæ™¯åŠ è½½å®Œæˆ
          await new Promise(resolve => {
            if (scene.hasLoaded) {
              resolve();
            } else {
              scene.addEventListener('loaded', resolve);
            }
          });

          loadingText.style.display = 'none';
          console.log('ARçŸ³çªŸå¤åŸåœºæ™¯å·²å¯åŠ¨');

          // å¯åŠ¨åœºæ™¯
          setupScene();

        } catch (error) {
          console.error('å¯åŠ¨ARå¤±è´¥:', error);
          alert('å¯åŠ¨ARå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™å¹¶åˆ·æ–°é¡µé¢é‡è¯•');
          startScreen.style.display = 'flex';
          scene.style.display = 'none';
        }
      });

      // åœºæ™¯è®¾ç½®å‡½æ•°
      function setupScene() {
        const targetEntity = document.querySelector('[mindar-image-target]');

        // æ·»åŠ ç²’å­ç³»ç»Ÿ
        targetEntity.setAttribute('particle-system', '');

        // è‰²åº¦è§†é¢‘æ’­æ”¾æ§åˆ¶
        const seduVideo = document.getElementById('seduVideo');
        const seduVideoPlane = document.getElementById('seduVideoPlane');

        // åˆå§‹éšè—è‰²åº¦è§†é¢‘ï¼Œåªåœ¨è¯†åˆ«åˆ°æ ‡è®°æ—¶æ’­æ”¾
        if (seduVideoPlane) {
          seduVideoPlane.setAttribute('visible', 'false');
        }

        if (targetEntity) {
          // ç›®æ ‡æ£€æµ‹äº‹ä»¶ - å½“å‘ç°æ ‡è®°å›¾åƒæ—¶è§¦å‘
          targetEntity.addEventListener('targetFound', function () {
            console.log('å‘ç°åƒä½›æ´æ ‡è®°');

            // æ’­æ”¾è‰²åº¦è§†é¢‘
            const seduVideo = document.getElementById('seduVideo');
            const seduVideoPlane = document.getElementById('seduVideoPlane');

            if (seduVideo && seduVideoPlane) {
              console.log('ğŸ¬ å¼€å§‹æ’­æ”¾è‰²åº¦è§†é¢‘');

              // æ˜¾ç¤ºè§†é¢‘
              seduVideoPlane.setAttribute('visible', 'true');

              // è®¾ç½®éŸ³é‡å’Œå–æ¶ˆé™éŸ³
              seduVideo.muted = false;
              seduVideo.volume = 0.8;

              // é‡ç½®æ’­æ”¾æ—¶é—´å¹¶æ’­æ”¾
              seduVideo.currentTime = 0;
              const playPromise = seduVideo.play();

              if (playPromise !== undefined) {
                playPromise.then(() => {
                  console.log('âœ… è‰²åº¦è§†é¢‘æ’­æ”¾æˆåŠŸï¼Œå£°éŸ³å·²å¯ç”¨');
                }).catch(error => {
                  console.error('âŒ è‰²åº¦è§†é¢‘æ’­æ”¾å¤±è´¥:', error);
                });
              }

              // ç›‘å¬è§†é¢‘æ’­æ”¾ç»“æŸäº‹ä»¶
              seduVideo.onended = function () {
                console.log('ğŸ¬ é€æ˜è§†é¢‘æ’­æ”¾å®Œæ¯•ï¼Œæ˜¾ç¤ºæ¨¡å‹');

                // éšè—è§†é¢‘
                seduVideoPlane.setAttribute('visible', 'false');

                // æ˜¾ç¤ºçŸ³çªŸæ¨¡å‹
                const caveModel = document.getElementById('caveModel3D');
                if (caveModel) {
                  caveModel.setAttribute('visible', 'true');
                }

                // æ˜¾ç¤ºå¹¶å¯åŠ¨é¾™çš„åŠ¨ç”»
                const dragonModel = document.getElementById('dragon');
                if (dragonModel) {
                  dragonModel.setAttribute('visible', 'true');
                  dragonModel.setAttribute('opacity', '0');
                  dragonModel.setAttribute('animation__fadein',
                    'property: opacity; from: 0; to: 1; dur: 2000; delay: 1000');
                }

                // æ’­æ”¾éŸ³æ•ˆ
                if (magicSound) {
                  magicSound.currentTime = 0;
                  magicSound.play().catch(e => console.log('é­”æ³•éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e));
                }

                // å»¶è¿Ÿæ’­æ”¾é’Ÿå£°
                setTimeout(() => {
                  if (bellSound) {
                    bellSound.play().catch(e => console.log('é’Ÿå£°æ’­æ”¾å¤±è´¥:', e));
                  }
                }, 1500);

                // å»¶è¿Ÿæ’­æ”¾æ¢µéŸ³
                setTimeout(() => {
                  if (chantAudio) {
                    chantAudio.play().catch(e => console.log('æ¢µéŸ³æ’­æ”¾å¤±è´¥:', e));
                  }
                }, 3000);
              };
            }

            const caveModel = document.getElementById('caveModel3D');
            const dragonModel = document.getElementById('dragon');

          });

          // ç›®æ ‡ä¸¢å¤±äº‹ä»¶ - å½“æ ‡è®°å›¾åƒç¦»å¼€è§†é‡æ—¶è§¦å‘
          targetEntity.addEventListener('targetLost', function () {
            console.log('ç›®æ ‡ä¸¢å¤± - æš‚åœéŸ³æ•ˆå’Œé‡ç½®çŠ¶æ€');

            // æš‚åœéŸ³æ•ˆ
            if (chantAudio) chantAudio.pause();
            if (magicSound) magicSound.pause();

            // æš‚åœè‰²åº¦è§†é¢‘
            const seduVideo = document.getElementById('seduVideo');
            const seduVideoPlane = document.getElementById('seduVideoPlane');
            if (seduVideo) {
              seduVideo.pause();
              console.log('â¸ï¸ è‰²åº¦è§†é¢‘å·²æš‚åœ');
            }
            if (seduVideoPlane) {
              seduVideoPlane.setAttribute('visible', 'false');
            }



            const caveModel = document.getElementById('caveModel3D');
            const dragonModel = document.getElementById('dragon');


            if (caveModel) caveModel.setAttribute('visible', 'false');
            if (dragonModel) dragonModel.setAttribute('visible', 'false');
          });
        }
      }

      // ç›‘å¬æ¨¡å‹åŠ è½½äº‹ä»¶
      const models = document.querySelectorAll('a-gltf-model');
      models.forEach(model => {
        model.addEventListener('model-loaded', function () {
          console.log('æ¨¡å‹åŠ è½½å®Œæˆ:', model.id);
        });

        model.addEventListener('model-error', function (event) {
          console.log('æ¨¡å‹åŠ è½½å¤±è´¥:', model.id, '(è¿™æ˜¯å¯é€‰æ¨¡å‹ï¼Œä¸å½±å“ä¸»ä½“åŠŸèƒ½)');
        });
      });
    });
  </script>
</body>

</html>